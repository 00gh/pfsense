#!/bin/sh

# $Id$
# /etc/rc.firmware
# part of m0n0wall (http://neon1.net/m0n0wall)
#
# Copyright (C) 2003 Manuel Kasper <mk@neon1.net>.
# All rights reserved.

#CFDEVICE=`cat /var/etc/cfdevice`

if [ $1 != "upgrade" ]; then
	/sbin/umount -f /ftmp > /dev/null 2>&1
fi

backup_chflags() {
	/usr/sbin/mtree -Pcp / | bzip2 -9 > /tmp/chflags.dist.bz2
}

restore_chflags() {
	cd / && /usr/bin/bzcat /tmp/chflags.dist.bz2 | /usr/sbin/mtree -PU -p /
}

remove_chflags() {
	/usr/bin/chflags -R noschg /
	/bin/chmod -R u+rw /
}

binary_update() {
	TGZ=$1
	ERR_F="/tmp/bdiff.log"
	rm ${ERR_F} 2>/dev/null
	/bin/mkdir /tmp/patched /tmp/patches 2>>${ERR_F}
	backup_chflags
	remove_chflags
	cd /tmp/patches
	for i in `/usr/bin/tar tvzf $TGZ | egrep -v "(^d|_md5)" | nawk '{print $9;}'`;
	 do 
	   FILE=`basename ${i}`
	   echo "Working on ${i}"
	   # Untar patch file and md5 files
	   /usr/bin/tar xzf ${TGZ} ${i} ${i}.old_file_md5 ${i}.new_patch_md5 ${i}.new_file_md5 2>>${ERR_F}

	   # Apply patch - oldfile newfile patchfile
	   /usr/local/bin/bspatch /${i} /tmp/patched/${FILE} /tmp/patches/${i} 2>>${ERR_F}

	   OLD_FILE_MD5=`cat /tmp/patches/${i}.old_file_md5 2>/dev/null`
	   NEW_PATCH_MD5=`cat /tmp/patches/${i}.new_patch_md5 2>/dev/null`
	   NEW_FILE_MD5=`cat /tmp/patches/${i}.new_file_md5 2>/dev/null`
	   PATCHED_MD5=`/sbin/md5 -q /tmp/patched/${FILE} 2>/dev/null`

	   if [ "$PATCHED_MD5" = "$NEW_PATCH_MD5" ]; then
		/usr/bin/install -S  /tmp/patched/${FILE} /${i}
	   else
		#echo "${i} file does not match intended final md5."
		echo "${i} file does not match intended final md5." >> ${ERR_F}
	   fi

	   /bin/rm /tmp/patched/${FILE} >> ${ERR_F}
	   /bin/rm /tmp/patches/${i} >> ${ERR_F}
	   /bin/rm /tmp/patches/${i}.* >> ${ERR_F}
	done
	/bin/rm -rf /tmp/patched /tmp/patches >> ${ERR_F}
	restore_chflags
}

case $1 in
enable)
	/sbin/mount_mfs -s 15360 -T qp120at -b 8192 -f 1024 dummy /ftmp \
		> /dev/null 2>&1
	;;
auto)
	backup_chflags
	remove_chflags
	/etc/rc.firmware_auto
	restore_chflags
	;;
upgrade)
	# wait 5 seconds before beginning
	sleep 5
	backup_chflags
	remove_chflags
	
	exec </dev/console >/dev/console 2>/dev/console

	echo
	echo "Firmware upgrade in progress..."  | logger -p daemon.info -i -t Upgrade

	# backup config
	mkdir /tmp/configbak
	cp -p /conf/* /tmp/configbak

	# unmount /cf
	/sbin/umount -f /cf

	# dd image onto card
	if [ -r $2 ]; then
		/usr/bin/gunzip -S "" -c $2 | dd of=/dev/r$CFDEVICE bs=16k > /dev/null 2>&1
		echo "Image installed."
	fi

	# mount /cf
	/sbin/mount -w -o noatime /cf

	# restore config
	cp -p /tmp/configbak/* /conf

	restore_chflags

	# remount /cf ro
	/sbin/umount -f /cf
	/sbin/mount -r /cf

	echo "Done."
	/etc/rc.reboot
	;;
pfSenseupgrade)
	# wait 5 seconds before beginning
	sleep 5
	backup_chflags
	remove_chflags

	exec </dev/console >/dev/console 2>/dev/console

	echo "Firmware upgrade in progress..."  | logger -p daemon.info -i -t Upgrade

	# backup config
	/bin/mkdir /tmp/configbak
	cp -p /conf/* /tmp/configbak
	# mount /cf
	/sbin/mount -w -o noatime /cf

	# tar explode image onto hd
	if [ -r $2 ]; then
		echo "Installing $2." | logger -p daemon.info -i -t Upgrade
		/usr/bin/tar xzPf $2 -U -C / | logger -p daemon.info -i -t Upgrade
		/usr/bin/find / -name CVS -exec rm {} \;
		echo "Image installed $2." | logger -p daemon.info -i -t Upgrade
	else
		echo "2nd paramater has not been passed; skipping." | logger -p daemon.info -i -t Upgrade
	fi

        # process custom image if its passed
        if [ -r $3 ]; then
            echo "Custom image $3 found." | logger -p daemon.info -i -t Upgrade
            /usr/bin/tar xzPf $3 -U -C / | logger -p daemon.info -i -t Upgrade
            echo "Custom image $3 installed." | logger -p daemon.info -i -t Upgrade
        fi

	# restore config
	cp -p /tmp/configbak/* /conf

	# restore /etc symlinks
	rm /etc/hosts
	ln -s /var/etc/hosts /etc/hosts

	restore_chflags

	# remount /cf ro
	/sbin/umount -f /cf
	/sbin/mount -r /cf
	
	echo "Done." | logger -p daemon.info -i -t Upgrade
	/etc/rc.reboot
	;;
delta_update)
	backup_chflags
	remove_chflags
	binary_update $2
	restore_chflags
	;;
esac
