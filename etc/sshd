#! /usr/local/bin/php -f
<?php
/*
	sshd - Modified to work on disk based system
	Copyright 2004 Scott K Ullrich

	Original Copyright (C) 2004 Fred Mol <fredmol@xs4all.nl>.
	All rights reserved.

	Redistribution and use in source and binary forms, with or without
	modification, are permitted provided that the following conditions are met:

	1. Redistributions of source code must retain the above copyright notice,
	   this list of conditions and the following disclaimer.

	2. Redistributions in binary form must reproduce the above copyright
	   notice, this list of conditions and the following disclaimer in the
	   documentation and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
	INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
	AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
	AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
	OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
	SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
	INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
	CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
	ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
	POSSIBILITY OF SUCH DAMAGE.
*/

	require("functions.inc");

	/* exit, if sshd is not enabled */
	if (! isset($config['system']['ssh']['enable'])) {
		if($g['booting'])
			echo "SSHD is disabled.";
		exit;
	}

	/* specify the locations of sshd's configuration */
	$ssh_cfg_dir  = "{$g['etc_path']}/ssh";
	$sshd_pidfile = "{$g['varrun_path']}/sshd.pid";
	$sshd_config  = "{$ssh_cfg_dir}/sshd_config";

	/* create ssh configuration directory */
	if(! is_dir($ssh_cfg_dir))
		mkdir($ssh_cfg_dir, 0755);

	/* if any of these files are 0 bytes then they are corrupted -> remove them */
	exec("find ../../" . ($g['platform'] == "pfSense" ? "home" : "var/home") . " -name authorized_keys", $files_in_homes);
	$files_to_check = array_merge(
		array(
			'ssh_host_dsa_key', 'ssh_host_dsa_key.pub', 'ssh_host_key', 'ssh_host_key.pub',
			'ssh_host_rsa_key', 'ssh_host_rsa_key.pub', '../../root/.ssh/authorized_keys'
		),
		$files_in_homes
	);
	foreach($files_to_check as $f2c)
		if(file_exists("{$ssh_cfg_dir}/{$f2c}") && filesize("{$ssh_cfg_dir}/{$f2c}") == 0) {
			if(basename($f2c) == "authorized_keys")
				mwexec("rm {$ssh_cfg_dir}/{$f2c}");
			else
				mwexec("rm {$ssh_cfg_dir}/ssh_host_*");
		}

	/* create ssh home directory */
	if(! is_dir("/var/empty"))
		mkdir("/var/empty", 0555);

	/* login related files */
	if(! file_exists(""))
		touch("/var/log/lastlog");

	/* sync passwords and create per-user authorized_keys file */
	system_password_configure();
	conf_mount_rw();

	/* include default configuration for pfSense */
	$sshconf  = "#\n";
	$sshconf .= "# pfSense SSHd configuration file\n";
	$sshconf .= "# This file is automatically generated at startup\n";
	$sshconf .= "#\n";
	$sshconf .= "Compression yes\n";
	$sshconf .= "ClientAliveInterval 30\n";
	$sshconf .= "ClientAliveCountMax 3\n";
	$sshconf .= "IgnoreRhosts yes\n";
	$sshconf .= "LoginGraceTime 60\n";
	$sshconf .= "MaxStartups 5\n";
	$sshconf .= "PermitEmptyPasswords no\n";
	$sshconf .= "PermitRootLogin yes\n";
	$sshconf .= "PidFile {$sshd_pidfile}\n";
	$sshconf .= "Protocol 2\n";
	$sshconf .= "UseDNS no\n";
	$sshconf .= "VersionAddendum\n";
	$sshconf .= "X11Forwarding no\n\n";

	/* run the server on another port (if we have one defined) */
	if($config['system']['ssh']['port'] <> "")
		$sshconf .= "Port " . $config['system']['ssh']['port'] . "\n";
	else
		$sshconf .= "Port 22\n";

	/* listen on all or specified interfaces only */
	/* note: if no interfaces are specified or "*" is set, bind to all interfaces */
	if($config['system']['ssh']['interfaces'] <> "") {
		$sshifaces = explode(" ", $config['system']['ssh']['interfaces']);
		if(! in_array("*", $sshifaces))
			foreach($sshifaces as $iface) {
				$ipv4 = get_interface_address($iface, 4);
				if($ipv4)
					$sshconf .= "ListenAddress " . $ipv4 . "\n";
//				$ipv6 = get_interface_address($iface, 6);
//				if($ipv6)
//					$sshconf .= "ListenAddress " . $ipv6 . "\n";
			}
	}

	if(isset($config['system']['ssh']['sshdkeyonly'])) {
		$sshconf .= "\n# Login via Key only\n";
		$sshconf .= "PasswordAuthentication no\n";
		$sshconf .= "ChallengeResponseAuthentication no\n";
		$sshconf .= "PubkeyAuthentication yes\n";
	} else {
		$sshconf .= "\n# Login via Key and Password\n";
		$sshconf .= "PasswordAuthentication yes\n";
		$sshconf .= "ChallengeResponseAuthentication yes\n";
		$sshconf .= "PubkeyAuthentication yes\n";
	}

// TODO: allow SCP to be disabled (via the webConfigurator or a hidden option)
	$sshconf .= "\n# SFTP server subsystem\n";
	$sshconf .= "Subsystem sftp /usr/libexec/sftp-server\n";

	/* write the new sshd config file */
	$fd = fopen($sshd_config, "w");
	fwrite($fd, $sshconf);
	fclose($fd);

// FIXME: this seems to be completely outdated (but harmless)
	/* mop up from a badly implemented ssh keys -> cf backup */
	if($config['ssh']['dsa_key'] <> "") {
		write_config("Clearing outdated SSH keys from config.xml");
		unset($config['ssh']['dsa_key']);
		unset($config['ssh']['rsa_key']);
		unset($config['ssh']['rsa1_key']);
		unset($config['ssh']['dsa']);
		unset($config['ssh']['rsa']);
		unset($config['ssh']['rsa1']);
		unset($config['ssh']['ak']);
	}

	/* are we already running? if so exit. */
	if(file_exists("/tmp/keys_generating"))
		exit;

	if(!file_exists("{$ssh_cfg_dir}/ssh_host_key") or file_exists("/etc/keys_generating")) {
		/* remove previous keys and regenerate later */
		file_notice("SSH", "{$g['product_name']} has started creating your SSH keys.  SSH Startup will be delayed.  Please note that reloading the filter rules and changes will be delayed until this operation is completed.", "SSH KeyGen", "");
		conf_mount_rw();
		mwexec("rm {$ssh_cfg_dir}/ssh_host_*");
		touch("/etc/keys_generating");
		touch("/tmp/keys_generating");
		mwexec("echo 'Generating Keys:' 1>&2");
		system("/usr/bin/nice -n20 /usr/bin/ssh-keygen -t rsa1 -N '' -f {$ssh_cfg_dir}/ssh_host_key");
		system("/usr/bin/nice -n20 /usr/bin/ssh-keygen -t rsa -N '' -f {$ssh_cfg_dir}/ssh_host_rsa_key");
		system("/usr/bin/nice -n20 /usr/bin/ssh-keygen -t dsa -N '' -f {$ssh_cfg_dir}/ssh_host_dsa_key");
		unlink("/etc/keys_generating");
		unlink("/tmp/keys_generating");
		file_notice("SSH", "{$g['product_name']} has completed creating your SSH keys.  SSH is now started.", "SSH Startup", "");
		mwexec("echo 'Starting SSH... ' 1>&2");
	}

	/* kill existing sshd process: server only, not the childs */
	if(file_exists($sshd_pidfile)) {
		mwexec("echo 'stopping ssh' 1>&2");
		killbypid($sshd_pidfile);
	}

	/* launch new server process */
	$status = mwexec("/usr/sbin/sshd -f {$sshd_config}");
	if($status <> 0) {
		file_notice("sshd_startup", "SSHD failed to start.", "SSHD Daemon", "");
		mwexec("echo -n 'error!' 1>&2");
	}
	else
		mwexec("echo -n 'done.' 1>&2");

	conf_mount_ro();


/* ===== exit, since the following stuff needs more testing ===== */
	exit;
/* ============================================================== */


// TODO: here be dragons
	if(!file_exists("{$ssh_cfg_dir}/ssh_host_key") and $config['ssh']['dsa'] == "") {
		/* generate keys */
		system("/usr/bin/nice -n20 /usr/bin/ssh-keygen -t rsa1 -N '' -f {$ssh_cfg_dir}/ssh_host_key");
		system("/usr/bin/nice -n20 /usr/bin/ssh-keygen -t rsa -N '' -f {$ssh_cfg_dir}/ssh_host_rsa_key");
		system("/usr/bin/nice -n20 /usr/bin/ssh-keygen -t dsa -N '' -f {$ssh_cfg_dir}/ssh_host_dsa_key");

		/* save keys */
		$dsa  = file_get_contents("{$ssh_cfg_dir}/ssh_host_dsa_key");
		$rsa  = file_get_contents("{$ssh_cfg_dir}/ssh_host_rsa_key");
		$rsa1 = file_get_contents("{$ssh_cfg_dir}/ssh_host_key");
		$config['ssh']['dsa'] = base64_encode($dsa);
		$config['ssh']['rsa'] = base64_encode($rsa);
		$config['ssh']['rsa1']= base64_encode($rsa1);

		/* save public keys */
		$dsapub  = file_get_contents("{$ssh_cfg_dir}/ssh_host_dsa_key.pub");
		$rsapub  = file_get_contents("{$ssh_cfg_dir}/ssh_host_rsa_key.pub");
		$rsa1pub = file_get_contents("{$ssh_cfg_dir}/ssh_host_key.pub");
		$config['ssh']['dsa_key'] = base64_encode($dsapub);
		$config['ssh']['rsa_key'] = base64_encode($rsapub);
		$config['ssh']['rsa1_key']= base64_encode($rsa1pub);
		write_config("Saved SSH keys.");
	} else {
		/* restore keys */
		$rsa1 = base64_decode($config['ssh']['rsa1']);
		$rsa  = base64_decode($config['ssh']['rsa']);
		$dsa  = base64_decode($config['ssh']['dsa']);
		file_put_contents("{$ssh_cfg_dir}/ssh_host_key", $rsa1);
		file_put_contents("{$ssh_cfg_dir}/ssh_host_rsa_key", $rsa);
		file_put_contents("{$ssh_cfg_dir}/ssh_host_dsa_key", $dsa);

		/* restore public keys */
		$rsa1_pub = base64_decode($config['ssh']['rsa1_key']);
		$rsa_pub  = base64_decode($config['ssh']['rsa_key']);
		$dsa_pub  = base64_decode($config['ssh']['dsa_key']);
		file_put_contents("{$ssh_cfg_dir}/ssh_host_key.pub", $rsa1_pub);
		file_put_contents("{$ssh_cfg_dir}/ssh_host_rsa_key.pub", $rsa_pub);
		file_put_contents("{$ssh_cfg_dir}/ssh_host_dsa_key.pub", $dsa_pub);

		/* change keys owner to root */
		chown("{$ssh_cfg_dir}/ssh_host_key", "root");
		chown("{$ssh_cfg_dir}/ssh_host_rsa_key", "root");
		chown("{$ssh_cfg_dir}/ssh_host_dsa_key", "root");

		/* change public keys owner to root */
		chown("{$ssh_cfg_dir}/ssh_host_key.pub", "root");
		chown("{$ssh_cfg_dir}/ssh_host_rsa_key.pub", "root");
		chown("{$ssh_cfg_dir}/ssh_host_dsa_key.pub", "root");

		/* change mode on keys to u+rw */
		chmod("{$ssh_cfg_dir}/ssh_host_key",0600);
		chmod("{$ssh_cfg_dir}/ssh_host_rsa_key",0600);
		chmod("{$ssh_cfg_dir}/ssh_host_dsa_key",0600);

		/* change mode on public keys to u+rw */
		chmod("{$ssh_cfg_dir}/ssh_host_key.pub",0600);
		chmod("{$ssh_cfg_dir}/ssh_host_rsa_key.pub",0600);
		chmod("{$ssh_cfg_dir}/ssh_host_dsa_key.pub",0600);
	}

	/* start sshd */
	system("/usr/sbin/sshd -f {$sshd_config}");
	echo "done.\n";
?>
